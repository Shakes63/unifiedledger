Claude Code

***Features***

check the features.md in the docs folder and start on the next incomplete task. Before implementing please think hard and make a detailed step by step plan for doing so making sure to integrate it well into the existing application architecture as well as UI and styling using the theme variables everywhere it makes sense to. the plan should be added to a file in the docs folder. When the plan is complete start on the first task in the plan.

update the features.md and claude.md files making sure to note if the task was not completed all the way and where to find the plan file for it if there is one. always leave a section at the top of the features.md file for me to add more features. if a feature has been completed then only leave the name of the feature marked completed and a 1 line description and remove the plan file. then commit and push the changes.

***Bugs***

check the bugs.md in the docs folder and start on the next incomplete task. Before implementing please think hard and make a detailed step by step plan for doing so making sure to integrate it well into the existing application architecture as well as UI and styling using the theme variables everywhere it makes sense to. the plan should be added to a file in the docs folder. When the plan is complete start on the first task in the plan.

update the bugs.md and claude.md files making sure to note if the task was not completed all the way and where to find the plan file for it if there is one. always leave a section at the top of the bugs.md file for me to add more bugs. if a bug has been completely fixed then only leave the name of the bug marked fixed and a 1 or 2 line description of the fix and remove the plan file. then commit and push the changes.



Cursor

***Features***

Review docs/features.md and keep completing features until the context window is nearly full or there are no unfinished features left.
For each feature:
Before coding: write docs/<feature>-plan.md (steps + edge cases, fits existing architecture/UI, uses theme variables, strict TypeScript—no any).
Implement the first task from the plan.
Update docs/features.md and .cursor/rules:
Keep “New Features” at the top of docs/features.md.
For incomplete features: include status, what’s left, and link the plan.
For completed features: Feature Name [COMPLETED YYYY-MM-DD] - 1 line, then delete the plan.
If part of Unified Architecture: mark the relevant phase complete in docs/unified-debt-bill-credit-card-architecture.md.
Add a manual check to docs/manual-testing-checklist.md.
Commit and push as you go (or at least at the end if time is tight).

***Bugs***

Review docs/bugs.md and keep fixing bugs until the context window is nearly full or there are no unfinished bugs left.
For each bug:
Before coding: write docs/<bug>-fix-plan.md (steps, architecture/UI fit, theme variables, strict TypeScript—no any).
Implement the first task from the plan.
Update docs/bugs.md and .cursor/rules:
Keep “New Bugs” at the top of docs/bugs.md.
For incomplete bugs: include status, what’s left, and link the plan.
For completed bugs: Bug Name [FIXED YYYY-MM-DD] - 1–2 line summary, delete the plan file, and add a small Testing Library regression test.
Commit and push changes as you go (or at least at the end if time is tight).

***Manual Testing***

Review docs/manual-testing-checklist.md and use the browser to test the next unchecked section.
Go to the relevant page(s) and test each checklist item.
For each item:
Mark [x] if it passes
Mark [!] if it fails and add a short note
Leave [ ] if not tested
If you find a bug, add it to docs/bugs.md with title/description, repro steps, and expected vs actual.
After finishing a section, record the test date/results, then move to the next section until done or out of time.
Prioritize correctness, UI/UX, and edge cases; watch console + network during testing.

***Retest Fixed Bugs***

Retest previously failed checklist items that should be fixed:
Find all [!] items in docs/manual-testing-checklist.md.
Confirm the related bug is marked fixed in docs/bugs.md.
Retest in the browser:
If it passes: change [!] → [x] and update/remove the note
If it still fails: keep [!] and update the note
If new issues appear: add a new entry to docs/bugs.md
Update the section’s Last Tested date.
Continue until all eligible [!] items are retested; watch console + network for regressions.

***Unraid CA Deployment (SQLite default + Optional Postgres)***

Review docs/unraid-ca-deployment-plan.md and implement the next unfinished step(s) until the context window is nearly full or the plan is fully implemented.
Treat docs/unraid-ca-deployment-plan.md as the source of truth; keep decisions consistent with what’s written there (migrations via drizzle-kit migrate, single-container entrypoint, /config persistence, Postgres officially supported 17+, /api/health checks DB, FORCE_SECURE_COOKIES defaults false).

Before coding:
Write docs/unraid-ca-deployment-implementation-plan.md with:
- concrete file-level changes (Dockerfile/entrypoint/scripts, drizzle configs, DB adapter switch, Better Auth provider switch)
- non-interactive upgrade behavior and failure modes
- SQLite vs Postgres differences + how migrations are selected
- reverse proxy requirements (NEXT_PUBLIC_APP_URL, forwarded headers)
- data persistence contract (/config/finance.db, /config/uploads) + backup/restore notes

Then implement the first task from the plan.
Update docs/unraid-ca-deployment-plan.md as you learn things during implementation so it stays accurate.
Add/adjust README sections needed for Unraid users (env vars, ports, first-run behavior, upgrades).
Prefer strict TypeScript (no any), follow existing architecture patterns, and don’t hardcode secrets.
Commit and push changes as you go (or at least at the end if time is tight).